"use strict";
/*export * from "./base";
export * from "./transformer";
export * from "./visitor";
export * from "./astBuilder";
export * from "./decorator";
export * from "./path";
export * from "./simpleParser"
import * as utils from "./utils";
export { utils };
*/
Object.defineProperty(exports, "__esModule", { value: true });
exports.compileExample = void 0;
const asc = require("assemblyscript/cli/asc");
//import * as loader from "assemblyscript/lib/loader";
const CompileStringResult = false && asc.compileString("");
function compileExample(code, transform) {
    const res = compile(code, transform);
    return res.stdout.toString().trim().split("\n");
}
exports.compileExample = compileExample;
function compile(code, transform) {
    const baseDir = process.cwd();
    const res = asc.compileString(code, {
        transform,
        baseDir,
    });
    const errStr = res.stderr.toString();
    if (errStr) {
        throw new Error(errStr);
    }
    return res;
}
/*export function compileAndRun(code: string, transform: string): void {
  const res = compile(code, transform);
  const imports = { };
  const wasmModule = loader.instantiateSync(res.binary!.buffer, imports);
}
*/
console.log("RUN START");
var res = compileExample("" +
    "declare function includeBytes(path: string): StaticArray<u8>;" +
    "static DAYS_IN_MONTH: i32[] = includeBytes('testIB.dat');" +
    "console.log(DAYS_IN_MONTH.length);", "./src/examples/includeBytesTransform.ts");
res.forEach(element => { console.log(element); });
console.log("RUN END");
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZGVidWcuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi9zcmMvZGVidWcudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IjtBQUFBOzs7Ozs7Ozs7RUFTRTs7O0FBRUYsOENBQThDO0FBQzlDLHNEQUFzRDtBQUV0RCxNQUFNLG1CQUFtQixHQUFJLEtBQWMsSUFBSSxHQUFHLENBQUMsYUFBYSxDQUFDLEVBQUUsQ0FBQyxDQUFDO0FBUXJFLFNBQWdCLGNBQWMsQ0FBQyxJQUFZLEVBQUUsU0FBaUI7SUFDNUQsTUFBTSxHQUFHLEdBQUcsT0FBTyxDQUFDLElBQUksRUFBRSxTQUFTLENBQUMsQ0FBQztJQUNyQyxPQUFPLEdBQUcsQ0FBQyxNQUFNLENBQUMsUUFBUSxFQUFFLENBQUMsSUFBSSxFQUFFLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxDQUFDO0FBQ2xELENBQUM7QUFIRCx3Q0FHQztBQUVELFNBQVMsT0FBTyxDQUFDLElBQVksRUFBRSxTQUFpQjtJQUM5QyxNQUFNLE9BQU8sR0FBRyxPQUFPLENBQUMsR0FBRyxFQUFFLENBQUM7SUFDOUIsTUFBTSxHQUFHLEdBQWlCLEdBQUcsQ0FBQyxhQUFhLENBQUMsSUFBSSxFQUFFO1FBQ2hELFNBQVM7UUFDVCxPQUFPO0tBQ1IsQ0FBQyxDQUFDO0lBQ0gsTUFBTSxNQUFNLEdBQUcsR0FBRyxDQUFDLE1BQU0sQ0FBQyxRQUFRLEVBQUUsQ0FBQztJQUNyQyxJQUFJLE1BQU0sRUFBRTtRQUNWLE1BQU0sSUFBSSxLQUFLLENBQUMsTUFBTSxDQUFDLENBQUM7S0FDekI7SUFDRCxPQUFPLEdBQUcsQ0FBQztBQUNiLENBQUM7QUFFRDs7Ozs7RUFLRTtBQUVGLE9BQU8sQ0FBQyxHQUFHLENBQUMsV0FBVyxDQUFDLENBQUE7QUFDeEIsSUFBSSxHQUFHLEdBQUMsY0FBYyxDQUFDLEVBQUU7SUFDVCwrREFBK0Q7SUFDL0QsMkRBQTJEO0lBQzNELG9DQUFvQyxFQUd4Qyx5Q0FBeUMsQ0FDeEMsQ0FBQztBQUVkLEdBQUcsQ0FBQyxPQUFPLENBQUMsT0FBTyxDQUFDLEVBQUUsR0FBRSxPQUFPLENBQUMsR0FBRyxDQUFDLE9BQU8sQ0FBQyxDQUFBLENBQUEsQ0FBQyxDQUFDLENBQUM7QUFDL0MsT0FBTyxDQUFDLEdBQUcsQ0FBQyxTQUFTLENBQUMsQ0FBQSIsInNvdXJjZXNDb250ZW50IjpbIi8qZXhwb3J0ICogZnJvbSBcIi4vYmFzZVwiO1xuZXhwb3J0ICogZnJvbSBcIi4vdHJhbnNmb3JtZXJcIjtcbmV4cG9ydCAqIGZyb20gXCIuL3Zpc2l0b3JcIjtcbmV4cG9ydCAqIGZyb20gXCIuL2FzdEJ1aWxkZXJcIjtcbmV4cG9ydCAqIGZyb20gXCIuL2RlY29yYXRvclwiO1xuZXhwb3J0ICogZnJvbSBcIi4vcGF0aFwiO1xuZXhwb3J0ICogZnJvbSBcIi4vc2ltcGxlUGFyc2VyXCJcbmltcG9ydCAqIGFzIHV0aWxzIGZyb20gXCIuL3V0aWxzXCI7XG5leHBvcnQgeyB1dGlscyB9O1xuKi9cblxuaW1wb3J0ICogYXMgYXNjIGZyb20gXCJhc3NlbWJseXNjcmlwdC9jbGkvYXNjXCI7XG4vL2ltcG9ydCAqIGFzIGxvYWRlciBmcm9tIFwiYXNzZW1ibHlzY3JpcHQvbGliL2xvYWRlclwiO1xuXG5jb25zdCBDb21waWxlU3RyaW5nUmVzdWx0ID0gKGZhbHNlIGFzIHRydWUpICYmIGFzYy5jb21waWxlU3RyaW5nKFwiXCIpO1xudHlwZSBDb21waWxlU3RyaW5nUmVzdWx0VHlwZSA9IHR5cGVvZiBDb21waWxlU3RyaW5nUmVzdWx0O1xuXG5pbnRlcmZhY2UgTWVtb3J5UmVzdWx0IGV4dGVuZHMgQ29tcGlsZVN0cmluZ1Jlc3VsdFR5cGUge1xuICBzdGRvdXQ6IGFzYy5NZW1vcnlTdHJlYW07XG4gIHN0ZGVycjogYXNjLk1lbW9yeVN0cmVhbTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNvbXBpbGVFeGFtcGxlKGNvZGU6IHN0cmluZywgdHJhbnNmb3JtOiBzdHJpbmcpOiBzdHJpbmdbXSB7XG4gIGNvbnN0IHJlcyA9IGNvbXBpbGUoY29kZSwgdHJhbnNmb3JtKTtcbiAgcmV0dXJuIHJlcy5zdGRvdXQudG9TdHJpbmcoKS50cmltKCkuc3BsaXQoXCJcXG5cIik7XG59XG5cbmZ1bmN0aW9uIGNvbXBpbGUoY29kZTogc3RyaW5nLCB0cmFuc2Zvcm06IHN0cmluZyk6IE1lbW9yeVJlc3VsdCB7XG4gIGNvbnN0IGJhc2VEaXIgPSBwcm9jZXNzLmN3ZCgpO1xuICBjb25zdCByZXMgPSA8TWVtb3J5UmVzdWx0PmFzYy5jb21waWxlU3RyaW5nKGNvZGUsIHtcbiAgICB0cmFuc2Zvcm0sXG4gICAgYmFzZURpcixcbiAgfSk7XG4gIGNvbnN0IGVyclN0ciA9IHJlcy5zdGRlcnIudG9TdHJpbmcoKTtcbiAgaWYgKGVyclN0cikge1xuICAgIHRocm93IG5ldyBFcnJvcihlcnJTdHIpO1xuICB9XG4gIHJldHVybiByZXM7XG59XG5cbi8qZXhwb3J0IGZ1bmN0aW9uIGNvbXBpbGVBbmRSdW4oY29kZTogc3RyaW5nLCB0cmFuc2Zvcm06IHN0cmluZyk6IHZvaWQge1xuICBjb25zdCByZXMgPSBjb21waWxlKGNvZGUsIHRyYW5zZm9ybSk7XG4gIGNvbnN0IGltcG9ydHMgPSB7IH07XG4gIGNvbnN0IHdhc21Nb2R1bGUgPSBsb2FkZXIuaW5zdGFudGlhdGVTeW5jKHJlcy5iaW5hcnkhLmJ1ZmZlciwgaW1wb3J0cyk7XG59XG4qL1xuXG5jb25zb2xlLmxvZyhcIlJVTiBTVEFSVFwiKVxudmFyIHJlcz1jb21waWxlRXhhbXBsZShcIlwiKyBcbiAgICAgICAgICAgICAgICBcImRlY2xhcmUgZnVuY3Rpb24gaW5jbHVkZUJ5dGVzKHBhdGg6IHN0cmluZyk6IFN0YXRpY0FycmF5PHU4PjtcIitcbiAgICAgICAgICAgICAgICBcInN0YXRpYyBEQVlTX0lOX01PTlRIOiBpMzJbXSA9IGluY2x1ZGVCeXRlcygndGVzdElCLmRhdCcpO1wiK1xuICAgICAgICAgICAgICAgIFwiY29uc29sZS5sb2coREFZU19JTl9NT05USC5sZW5ndGgpO1wiXG4gICAgICAgICAgICAgICAgLCBcblxuICAgICAgICAgICAgXCIuL3NyYy9leGFtcGxlcy9pbmNsdWRlQnl0ZXNUcmFuc2Zvcm0udHNcIlxuICAgICAgICAgICAgKTtcblxucmVzLmZvckVhY2goZWxlbWVudCA9PiB7Y29uc29sZS5sb2coZWxlbWVudCl9KTtcbmNvbnNvbGUubG9nKFwiUlVOIEVORFwiKVxuIl19