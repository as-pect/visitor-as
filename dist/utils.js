"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.hasWarningMessage = exports.hasErrorMessage = exports.StringBuilder = exports.updateSource = exports.isMethodNamed = exports.className = exports.isEntry = exports.isUserEntry = exports.cloneNode = exports.getName = exports.toString = exports.not = exports.isLibrary = exports.getDecorator = exports.hasDecorator = exports.isDecorator = exports.decorates = void 0;
const as_1 = require("../as");
const astBuilder_1 = require("./astBuilder");
const cloneDeep = require("lodash.clonedeep");
function decorates(node, name) {
    return node.name.text === name;
}
exports.decorates = decorates;
function isDecorator(name) {
    return (node) => decorates(node, name);
}
exports.isDecorator = isDecorator;
function hasDecorator(node, name) {
    var _a;
    let decl;
    if (node instanceof as_1.DeclarationStatement) {
        decl = node;
    }
    else {
        decl = node.declaration;
    }
    // because it could be undefined
    return ((_a = decl.decorators) === null || _a === void 0 ? void 0 : _a.some(isDecorator(name))) == true;
}
exports.hasDecorator = hasDecorator;
function getDecorator(node, name) {
    var _a;
    return (_a = node.decorators) === null || _a === void 0 ? void 0 : _a.find(isDecorator(name));
}
exports.getDecorator = getDecorator;
function isLibrary(node) {
    return node.isLibrary || node.internalPath.startsWith("~lib/rt/");
}
exports.isLibrary = isLibrary;
function not(fn) {
    return (t) => !fn(t);
}
exports.not = not;
function toString(node) {
    return astBuilder_1.ASTBuilder.build(node);
}
exports.toString = toString;
function getName(node) {
    if (node instanceof as_1.TypeNode) {
        return node.range.toString();
    }
    if (node instanceof as_1.ClassDeclaration || node instanceof as_1.InterfaceDeclaration) {
        return className(node);
    }
    return node.name.range.toString();
}
exports.getName = getName;
function cloneNode(node) {
    return cloneDeep(node);
}
exports.cloneNode = cloneNode;
function isUserEntry(node) {
    return node.range.source.sourceKind == as_1.SourceKind.USER_ENTRY;
}
exports.isUserEntry = isUserEntry;
function isEntry(node) {
    return isUserEntry(node) || node.range.source.sourceKind == as_1.SourceKind.LIBRARY_ENTRY;
}
exports.isEntry = isEntry;
function className(_class) {
    let name = _class.name.range.toString();
    const typeParameters = _class.typeParameters;
    if (typeParameters) {
        name += `<${typeParameters.map(getName).join(", ")}>`;
    }
    return name;
}
exports.className = className;
function isMethodNamed(name) {
    return (stmt) => stmt.kind == as_1.NodeKind.METHODDECLARATION && toString(stmt.name) === name;
}
exports.isMethodNamed = isMethodNamed;
function updateSource(program, newSource) {
    const sources = program.sources;
    for (let i = 0, len = sources.length; i < len; i++) {
        if (sources[i].internalPath == newSource.internalPath) {
            sources[i] = newSource;
            break;
        }
    }
}
exports.updateSource = updateSource;
class StringBuilder {
    constructor() {
        this.sb = [];
    }
    push(s) {
        this.sb.push(s);
    }
    finish(separator = "\n") {
        let res = this.sb.join(separator);
        this.sb = [];
        return res;
    }
    get last() { return this.sb[this.sb.length - 1]; }
}
exports.StringBuilder = StringBuilder;
/**
 *
 * @param emitter DiagnosticEmitter
 * @returns return true if emitter have ERROR message
 */
function hasErrorMessage(emitter) {
    return hasMessage(emitter, as_1.DiagnosticCategory.ERROR);
}
exports.hasErrorMessage = hasErrorMessage;
/**
*
* @param emitter DiagnosticEmitter
* @returns return true if emitter have WARNING message
*/
function hasWarningMessage(emitter) {
    return hasMessage(emitter, as_1.DiagnosticCategory.WARNING);
}
exports.hasWarningMessage = hasWarningMessage;
function hasMessage(emitter, category) {
    const diagnostics = emitter.diagnostics ? emitter.diagnostics : [];
    for (const msg of diagnostics) {
        if (msg.category === category) {
            return true;
        }
    }
    return false;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidXRpbHMuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi9zcmMvdXRpbHMudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7O0FBQUEsOEJBY2U7QUFDZiw2Q0FBMEM7QUFFMUMsTUFBTSxTQUFTLEdBQW1CLE9BQU8sQ0FBQyxrQkFBa0IsQ0FBQyxDQUFDO0FBRTlELFNBQWdCLFNBQVMsQ0FBQyxJQUFtQixFQUFFLElBQVk7SUFDekQsT0FBOEIsSUFBSSxDQUFDLElBQUssQ0FBQyxJQUFJLEtBQUssSUFBSSxDQUFDO0FBQ3pELENBQUM7QUFGRCw4QkFFQztBQUVELFNBQWdCLFdBQVcsQ0FBQyxJQUFZO0lBQ3RDLE9BQU8sQ0FBQyxJQUFJLEVBQUUsRUFBRSxDQUFDLFNBQVMsQ0FBQyxJQUFJLEVBQUUsSUFBSSxDQUFDLENBQUM7QUFDekMsQ0FBQztBQUZELGtDQUVDO0FBR0QsU0FBZ0IsWUFBWSxDQUMxQixJQUFnRSxFQUNoRSxJQUFZOztJQUVaLElBQUksSUFBSSxDQUFDO0lBQ1QsSUFBSSxJQUFJLFlBQVkseUJBQW9CLEVBQUU7UUFDeEMsSUFBSSxHQUFHLElBQUksQ0FBQztLQUNiO1NBQU07UUFDTCxJQUFJLEdBQUcsSUFBSSxDQUFDLFdBQVcsQ0FBQztLQUN6QjtJQUNELGdDQUFnQztJQUNoQyxPQUFPLE9BQUEsSUFBSSxDQUFDLFVBQVUsMENBQUUsSUFBSSxDQUFDLFdBQVcsQ0FBQyxJQUFJLENBQUMsTUFBSyxJQUFJLENBQUM7QUFDMUQsQ0FBQztBQVpELG9DQVlDO0FBRUQsU0FBZ0IsWUFBWSxDQUMxQixJQUEwQixFQUMxQixJQUFZOztJQUVaLE9BQU8sTUFBQSxJQUFJLENBQUMsVUFBVSwwQ0FBRSxJQUFJLENBQUMsV0FBVyxDQUFDLElBQUksQ0FBQyxDQUFFLENBQUM7QUFDbkQsQ0FBQztBQUxELG9DQUtDO0FBRUQsU0FBZ0IsU0FBUyxDQUFDLElBQVk7SUFDcEMsT0FBTyxJQUFJLENBQUMsU0FBUyxJQUFJLElBQUksQ0FBQyxZQUFZ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Q0FBQyxDQUFDO0lBQ2xCLENBQUM7SUFFRCxNQUFNLENBQUMsU0FBUyxHQUFHLElBQUk7UUFDckIsSUFBSSxHQUFHLEdBQUcsSUFBSSxDQUFDLEVBQUUsQ0FBQyxJQUFJLENBQUMsU0FBUyxDQUFDLENBQUM7UUFDbEMsSUFBSSxDQUFDLEVBQUUsR0FBRyxFQUFFLENBQUM7UUFDYixPQUFPLEdBQUcsQ0FBQztJQUNiLENBQUM7SUFFRCxJQUFLLElBQUksS0FBYSxPQUFPLElBQUksQ0FBQyxFQUFFLENBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQyxNQUFNLEdBQUUsQ0FBQyxDQUFDLENBQUEsQ0FBQSxDQUFDO0NBQ3pEO0FBZEQsc0NBY0M7QUFFRDs7OztHQUlHO0FBQ0YsU0FBZ0IsZUFBZSxDQUFDLE9BQTBCO0lBQ3pELE9BQU8sVUFBVSxDQUFDLE9BQU8sRUFBRSx1QkFBa0IsQ0FBQyxLQUFLLENBQUMsQ0FBQztBQUN2RCxDQUFDO0FBRkEsMENBRUE7QUFFRDs7OztFQUlFO0FBQ0YsU0FBZ0IsaUJBQWlCLENBQUMsT0FBMEI7SUFDMUQsT0FBTyxVQUFVLENBQUMsT0FBTyxFQUFFLHVCQUFrQixDQUFDLE9BQU8sQ0FBQyxDQUFDO0FBQ3pELENBQUM7QUFGRCw4Q0FFQztBQUVELFNBQVMsVUFBVSxDQUNqQixPQUEwQixFQUMxQixRQUE0QjtJQUU1QixNQUFNLFdBQVcsR0FBRyxPQUFPLENBQUMsV0FBVyxDQUFDLENBQUMsQ0FBQyxPQUFPLENBQUMsV0FBVyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUM7SUFDbkUsS0FBSyxNQUFNLEdBQUcsSUFBSSxXQUFXLEVBQUU7UUFDM0IsSUFBSSxHQUFHLENBQUMsUUFBUSxLQUFLLFFBQVEsRUFBRTtZQUMzQixPQUFPLElBQUksQ0FBQztTQUNmO0tBQ0o7SUFDRCxPQUFPLEtBQUssQ0FBQztBQUNmLENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge1xyXG4gIERlY29yYXRvck5vZGUsXHJcbiAgSWRlbnRpZmllckV4cHJlc3Npb24sXHJcbiAgRGVjbGFyYXRpb25TdGF0ZW1lbnQsXHJcbiAgU291cmNlLFxyXG4gIE5vZGUsXHJcbiAgU291cmNlS2luZCxcclxuICBQcm9ncmFtLFxyXG4gIENsYXNzRGVjbGFyYXRpb24sXHJcbiAgVHlwZU5vZGUsXHJcbiAgTm9kZUtpbmQsXHJcbiAgSW50ZXJmYWNlRGVjbGFyYXRpb24sXHJcbiAgRGlhZ25vc3RpY0VtaXR0ZXIsXHJcbiAgRGlhZ25vc3RpY0NhdGVnb3J5LFxyXG59IGZyb20gXCIuLi9hc1wiO1xyXG5pbXBvcnQgeyBBU1RCdWlsZGVyIH0gZnJvbSBcIi4vYXN0QnVpbGRlclwiO1xyXG5cclxuY29uc3QgY2xvbmVEZWVwOiA8VD4odDogVCkgPT4gVCA9IHJlcXVpcmUoXCJsb2Rhc2guY2xvbmVkZWVwXCIpO1xyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGRlY29yYXRlcyhub2RlOiBEZWNvcmF0b3JOb2RlLCBuYW1lOiBzdHJpbmcpOiBib29sZWFuIHtcclxuICByZXR1cm4gKDxJZGVudGlmaWVyRXhwcmVzc2lvbj5ub2RlLm5hbWUpLnRleHQgPT09IG5hbWU7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBpc0RlY29yYXRvcihuYW1lOiBzdHJpbmcpOiAobm9kZTogRGVjb3JhdG9yTm9kZSkgPT4gYm9vbGVhbiB7XHJcbiAgcmV0dXJuIChub2RlKSA9PiBkZWNvcmF0ZXMobm9kZSwgbmFtZSk7XHJcbn1cclxuXHJcblxyXG5leHBvcnQgZnVuY3Rpb24gaGFzRGVjb3JhdG9yKFxyXG4gIG5vZGU6IERlY2xhcmF0aW9uU3RhdGVtZW50IHwge2RlY2xhcmF0aW9uOiBEZWNsYXJhdGlvblN0YXRlbWVudH0sXHJcbiAgbmFtZTogc3RyaW5nXHJcbik6IGJvb2xlYW4ge1xyXG4gIGxldCBkZWNsO1xyXG4gIGlmIChub2RlIGluc3RhbmNlb2YgRGVjbGFyYXRpb25TdGF0ZW1lbnQpIHtcclxuICAgIGRlY2wgPSBub2RlO1xyXG4gIH0gZWxzZSB7XHJcbiAgICBkZWNsID0gbm9kZS5kZWNsYXJhdGlvbjsgXHJcbiAgfSBcclxuICAvLyBiZWNhdXNlIGl0IGNvdWxkIGJlIHVuZGVmaW5lZFxyXG4gIHJldHVybiBkZWNsLmRlY29yYXRvcnM/LnNvbWUoaXNEZWNvcmF0b3IobmFtZSkpID09IHRydWU7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBnZXREZWNvcmF0b3IoXHJcbiAgbm9kZTogRGVjbGFyYXRpb25TdGF0ZW1lbnQsXHJcbiAgbmFtZTogc3RyaW5nXHJcbik6IERlY29yYXRvck5vZGUge1xyXG4gIHJldHVybiBub2RlLmRlY29yYXRvcnM/LmZpbmQoaXNEZWNvcmF0b3IobmFtZSkpITtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGlzTGlicmFyeShub2RlOiBTb3VyY2UpOiBib29sZWFuIHtcclxuICByZXR1cm4gbm9kZS5pc0xpYnJhcnkgfHwgbm9kZS5pbnRlcm5hbFBhdGguc3RhcnRzV2l0aChcIn5saWIvcnQvXCIpO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gbm90PFQ+KGZuOiAodDogVCkgPT4gYm9vbGVhbik6ICh0OiBUKSA9PiBib29sZWFuIHtcclxuICByZXR1cm4gKHQ6IFQpID0+ICFmbih0KTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIHRvU3RyaW5nKG5vZGU6IE5vZGUpOiBzdHJpbmcge1xyXG4gIHJldHVybiBBU1RCdWlsZGVyLmJ1aWxkKG5vZGUpO1xyXG59XHJcblxyXG5pbnRlcmZhY2UgTmFtZWQge1xyXG4gIG5hbWU6IElkZW50aWZpZXJFeHByZXNzaW9uO1xyXG59XHJcblxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGdldE5hbWUobm9kZTogTm9kZSAmIE5hbWVkIHwgVHlwZU5vZGUpOiBzdHJpbmcge1xyXG4gIGlmIChub2RlIGluc3RhbmNlb2YgVHlwZU5vZGUpIHtcclxuICAgIHJldHVybiBub2RlLnJhbmdlLnRvU3RyaW5nKCk7XHJcbiAgfVxyXG4gIGlmIChub2RlIGluc3RhbmNlb2YgQ2xhc3NEZWNsYXJhdGlvbiB8fCBub2RlIGluc3RhbmNlb2YgSW50ZXJmYWNlRGVjbGFyYXRpb24pIHtcclxuICAgIHJldHVybiBjbGFzc05hbWUobm9kZSk7XHJcbiAgfVxyXG4gIHJldHVybiBub2RlLm5hbWUucmFuZ2UudG9TdHJpbmcoKTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGNsb25lTm9kZTxUIGV4dGVuZHMgTm9kZT4obm9kZTogVCk6IFQge1xyXG4gIHJldHVybiBjbG9uZURlZXAobm9kZSk7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBpc1VzZXJFbnRyeShub2RlOiBOb2RlKTogYm9vbGVhbiB7XHJcbiAgcmV0dXJuIG5vZGUucmFuZ2Uuc291cmNlLnNvdXJjZUtpbmQgPT0gU291cmNlS2luZC5VU0VSX0VOVFJZO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gaXNFbnRyeShub2RlOiBOb2RlKTogYm9vbGVhbiB7XHJcbiAgcmV0dXJuIGlzVXNlckVudHJ5KG5vZGUpIHx8IG5vZGUucmFuZ2Uuc291cmNlLnNvdXJjZUtpbmQgPT0gU291cmNlS2luZC5MSUJSQVJZX0VOVFJZO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gY2xhc3NOYW1lKF9jbGFzczogQ2xhc3NEZWNsYXJhdGlvbiB8ICBJbnRlcmZhY2VEZWNsYXJhdGlvbik6IHN0cmluZyB7XHJcbiAgbGV0IG5hbWUgPSBfY2xhc3MubmFtZS5yYW5nZS50b1N0cmluZygpO1xyXG4gIGNvbnN0IHR5cGVQYXJhbWV0ZXJzID0gX2NsYXNzLnR5cGVQYXJhbWV0ZXJzO1xyXG4gIGlmICh0eXBlUGFyYW1ldGVycykge1xyXG4gICAgbmFtZSArPSBgPCR7dHlwZVBhcmFtZXRlcnMubWFwKGdldE5hbWUpLmpvaW4oXCIsIFwiKX0+YDtcclxuICB9XHJcbiAgcmV0dXJuIG5hbWU7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBpc01ldGhvZE5hbWVkKG5hbWU6IHN0cmluZyk6IChfOiBEZWNsYXJhdGlvblN0YXRlbWVudCkgPT4gYm9vbGVhbiB7XHJcbiAgcmV0dXJuIChzdG10OiBEZWNsYXJhdGlvblN0YXRlbWVudCkgPT4gc3RtdC5raW5kID09IE5vZGVLaW5kLk1FVEhPRERFQ0xBUkFUSU9OICYmIHRvU3RyaW5nKHN0bXQubmFtZSkgPT09IG5hbWU7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiB1cGRhdGVTb3VyY2UocHJvZ3JhbTogUHJvZ3JhbSwgbmV3U291cmNlOiBTb3VyY2UpIHtcclxuICBjb25zdCBzb3VyY2VzID0gcHJvZ3JhbS5zb3VyY2VzO1xyXG4gIGZvciAobGV0IGkgPSAwLCBsZW4gPSBzb3VyY2VzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XHJcbiAgICAgIGlmIChzb3VyY2VzW2ldLmludGVybmFsUGF0aCA9PSBuZXdTb3VyY2UuaW50ZXJuYWxQYXRoKSB7XHJcbiAgICAgICAgICBzb3VyY2VzW2ldID0gbmV3U291cmNlO1xyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgIH1cclxuICB9XHJcbn1cclxuXHJcbmV4cG9ydCBjbGFzcyBTdHJpbmdCdWlsZGVyIHtcclxuICBwcml2YXRlIHNiOiBzdHJpbmdbXSA9IFtdO1xyXG5cclxuICBwdXNoKHM6IHN0cmluZyk6IHZvaWQge1xyXG4gICAgdGhpcy5zYi5wdXNoKHMpO1xyXG4gIH1cclxuXHJcbiAgZmluaXNoKHNlcGFyYXRvciA9IFwiXFxuXCIpOiBzdHJpbmcge1xyXG4gICAgbGV0IHJlcyA9IHRoaXMuc2Iuam9pbihzZXBhcmF0b3IpO1xyXG4gICAgdGhpcy5zYiA9IFtdO1xyXG4gICAgcmV0dXJuIHJlcztcclxuICB9XHJcblxyXG4gIGdldCAgbGFzdCgpOiBzdHJpbmcgeyByZXR1cm4gdGhpcy5zYlt0aGlzLnNiLmxlbmd0aCAtMV19XHJcbn1cclxuXHJcbi8qKlxyXG4gKlxyXG4gKiBAcGFyYW0gZW1pdHRlciBEaWFnbm9zdGljRW1pdHRlclxyXG4gKiBAcmV0dXJucyByZXR1cm4gdHJ1ZSBpZiBlbWl0dGVyIGhhdmUgRVJST1IgbWVzc2FnZVxyXG4gKi9cclxuIGV4cG9ydCBmdW5jdGlvbiBoYXNFcnJvck1lc3NhZ2UoZW1pdHRlcjogRGlhZ25vc3RpY0VtaXR0ZXIpOiBib29sZWFuIHtcclxuICByZXR1cm4gaGFzTWVzc2FnZShlbWl0dGVyLCBEaWFnbm9zdGljQ2F0ZWdvcnkuRVJST1IpO1xyXG59XHJcblxyXG4vKipcclxuKlxyXG4qIEBwYXJhbSBlbWl0dGVyIERpYWdub3N0aWNFbWl0dGVyXHJcbiogQHJldHVybnMgcmV0dXJuIHRydWUgaWYgZW1pdHRlciBoYXZlIFdBUk5JTkcgbWVzc2FnZVxyXG4qL1xyXG5leHBvcnQgZnVuY3Rpb24gaGFzV2FybmluZ01lc3NhZ2UoZW1pdHRlcjogRGlhZ25vc3RpY0VtaXR0ZXIpOiBib29sZWFuIHtcclxuICByZXR1cm4gaGFzTWVzc2FnZShlbWl0dGVyLCBEaWFnbm9zdGljQ2F0ZWdvcnkuV0FSTklORyk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGhhc01lc3NhZ2UoXHJcbiAgZW1pdHRlcjogRGlhZ25vc3RpY0VtaXR0ZXIsXHJcbiAgY2F0ZWdvcnk6IERpYWdub3N0aWNDYXRlZ29yeVxyXG4pOiBib29sZWFuIHtcclxuICBjb25zdCBkaWFnbm9zdGljcyA9IGVtaXR0ZXIuZGlhZ25vc3RpY3MgPyBlbWl0dGVyLmRpYWdub3N0aWNzIDogW107XHJcbiAgZm9yIChjb25zdCBtc2cgb2YgZGlhZ25vc3RpY3MpIHtcclxuICAgICAgaWYgKG1zZy5jYXRlZ29yeSA9PT0gY2F0ZWdvcnkpIHtcclxuICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICB9XHJcbiAgfVxyXG4gIHJldHVybiBmYWxzZTtcclxufVxyXG4iXX0=