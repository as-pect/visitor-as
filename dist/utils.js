"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.isUserEntry = exports.cloneNode = exports.toString = exports.not = exports.isLibrary = exports.getDecorator = exports.hasDecorator = exports.isDecorator = exports.decorates = void 0;
const as_1 = require("../as");
const astBuilder_1 = require("./astBuilder");
const cloneDeep = require("lodash.clonedeep");
function decorates(node, name) {
    return node.name.text === name;
}
exports.decorates = decorates;
function isDecorator(name) {
    return (node) => decorates(node, name);
}
exports.isDecorator = isDecorator;
function hasDecorator(node, name) {
    var _a;
    let decl;
    if (node instanceof as_1.DeclarationStatement) {
        decl = node;
    }
    else {
        decl = node.declaration;
    }
    // because it could be undefined
    return ((_a = decl.decorators) === null || _a === void 0 ? void 0 : _a.some(isDecorator(name))) == true;
}
exports.hasDecorator = hasDecorator;
function getDecorator(node, name) {
    var _a;
    return (_a = node.decorators) === null || _a === void 0 ? void 0 : _a.find(isDecorator(name));
}
exports.getDecorator = getDecorator;
function isLibrary(node) {
    return node.isLibrary || node.internalPath.startsWith("~lib/rt/");
}
exports.isLibrary = isLibrary;
function not(fn) {
    return (t) => !fn(t);
}
exports.not = not;
function toString(node) {
    return astBuilder_1.ASTBuilder.build(node);
}
exports.toString = toString;
function cloneNode(node) {
    return cloneDeep(node);
}
exports.cloneNode = cloneNode;
function isUserEntry(source) {
    return source.sourceKind == as_1.SourceKind.USER_ENTRY;
}
exports.isUserEntry = isUserEntry;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidXRpbHMuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi9zcmMvdXRpbHMudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7O0FBQUEsOEJBT2U7QUFDZiw2Q0FBMEM7QUFFMUMsTUFBTSxTQUFTLEdBQW1CLE9BQU8sQ0FBQyxrQkFBa0IsQ0FBQyxDQUFDO0FBRTlELFNBQWdCLFNBQVMsQ0FBQyxJQUFtQixFQUFFLElBQVk7SUFDekQsT0FBOEIsSUFBSSxDQUFDLElBQUssQ0FBQyxJQUFJLEtBQUssSUFBSSxDQUFDO0FBQ3pELENBQUM7QUFGRCw4QkFFQztBQUVELFNBQWdCLFdBQVcsQ0FBQyxJQUFZO0lBQ3RDLE9BQU8sQ0FBQyxJQUFJLEVBQUUsRUFBRSxDQUFDLFNBQVMsQ0FBQyxJQUFJLEVBQUUsSUFBSSxDQUFDLENBQUM7QUFDekMsQ0FBQztBQUZELGtDQUVDO0FBR0QsU0FBZ0IsWUFBWSxDQUMxQixJQUFnRSxFQUNoRSxJQUFZOztJQUVaLElBQUksSUFBSSxDQUFDO0lBQ1QsSUFBSSxJQUFJLFlBQVkseUJBQW9CLEVBQUU7UUFDeEMsSUFBSSxHQUFHLElBQUksQ0FBQztLQUNiO1NBQU07UUFDTCxJQUFJLEdBQUcsSUFBSSxDQUFDLFdBQVcsQ0FBQztLQUN6QjtJQUNELGdDQUFnQztJQUNoQyxPQUFPLE9BQUEsSUFBSSxDQUFDLFVBQVUsMENBQUUsSUFBSSxDQUFDLFdBQVcsQ0FBQyxJQUFJLENBQUMsTUFBSyxJQUFJLENBQUM7QUFDMUQsQ0FBQztBQVpELG9DQVlDO0FBRUQsU0FBZ0IsWUFBWSxDQUMxQixJQUEwQixFQUMxQixJQUFZOztJQUVaLE9BQU8sTUFBQSxJQUFJLENBQUMsVUFBVSwwQ0FBRSxJQUFJLENBQUMsV0FBVyxDQUFDLElBQUksQ0FBQyxDQUFFLENBQUM7QUFDbkQsQ0FBQztBQUxELG9DQUtDO0FBRUQsU0FBZ0IsU0FBUyxDQUFDLElBQVk7SUFDcEMsT0FBTyxJQUFJLENBQUMsU0FBUyxJQUFJLElBQUksQ0FBQyxZQUFZLENBQUMsVUFBVSxDQUFDLFVBQVUsQ0FBQyxDQUFDO0FBQ3BFLENBQUM7QUFGRCw4QkFFQztBQUVELFNBQWdCLEdBQUcsQ0FBSSxFQUFxQjtJQUMxQyxPQUFPLENBQUMsQ0FBSSxFQUFFLEVBQUUsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQztBQUMxQixDQUFDO0FBRkQsa0JBRUM7QUFFRCxTQUFnQixRQUFRLENBQUMsSUFBVTtJQUNqQyxPQUFPLHVCQUFVLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxDQUFDO0FBQ2hDLENBQUM7QUFGRCw0QkFFQztBQUVELFNBQWdCLFNBQVMsQ0FBaUIsSUFBTztJQUMvQyxPQUFPLFNBQVMsQ0FBQyxJQUFJLENBQUMsQ0FBQztBQUN6QixDQUFDO0FBRkQsOEJBRUM7QUFFRCxTQUFnQixXQUFXLENBQUMsTUFBYztJQUN4QyxPQUFPLE1BQU0sQ0FBQyxVQUFVLElBQUksZUFBVSxDQUFDLFVBQVUsQ0FBQztBQUNwRCxDQUFDO0FBRkQsa0NBRUMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge1xyXG4gIERlY29yYXRvck5vZGUsXHJcbiAgSWRlbnRpZmllckV4cHJlc3Npb24sXHJcbiAgRGVjbGFyYXRpb25TdGF0ZW1lbnQsXHJcbiAgU291cmNlLFxyXG4gIE5vZGUsXHJcbiAgU291cmNlS2luZCxcclxufSBmcm9tIFwiLi4vYXNcIjtcclxuaW1wb3J0IHsgQVNUQnVpbGRlciB9IGZyb20gXCIuL2FzdEJ1aWxkZXJcIjtcclxuXHJcbmNvbnN0IGNsb25lRGVlcDogPFQ+KHQ6IFQpID0+IFQgPSByZXF1aXJlKFwibG9kYXNoLmNsb25lZGVlcFwiKTtcclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBkZWNvcmF0ZXMobm9kZTogRGVjb3JhdG9yTm9kZSwgbmFtZTogc3RyaW5nKTogYm9vbGVhbiB7XHJcbiAgcmV0dXJuICg8SWRlbnRpZmllckV4cHJlc3Npb24+bm9kZS5uYW1lKS50ZXh0ID09PSBuYW1lO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gaXNEZWNvcmF0b3IobmFtZTogc3RyaW5nKTogKG5vZGU6IERlY29yYXRvck5vZGUpID0+IGJvb2xlYW4ge1xyXG4gIHJldHVybiAobm9kZSkgPT4gZGVjb3JhdGVzKG5vZGUsIG5hbWUpO1xyXG59XHJcblxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGhhc0RlY29yYXRvcihcclxuICBub2RlOiBEZWNsYXJhdGlvblN0YXRlbWVudCB8IHtkZWNsYXJhdGlvbjogRGVjbGFyYXRpb25TdGF0ZW1lbnR9LFxyXG4gIG5hbWU6IHN0cmluZ1xyXG4pOiBib29sZWFuIHtcclxuICBsZXQgZGVjbDtcclxuICBpZiAobm9kZSBpbnN0YW5jZW9mIERlY2xhcmF0aW9uU3RhdGVtZW50KSB7XHJcbiAgICBkZWNsID0gbm9kZTtcclxuICB9IGVsc2Uge1xyXG4gICAgZGVjbCA9IG5vZGUuZGVjbGFyYXRpb247IFxyXG4gIH0gXHJcbiAgLy8gYmVjYXVzZSBpdCBjb3VsZCBiZSB1bmRlZmluZWRcclxuICByZXR1cm4gZGVjbC5kZWNvcmF0b3JzPy5zb21lKGlzRGVjb3JhdG9yKG5hbWUpKSA9PSB0cnVlO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gZ2V0RGVjb3JhdG9yKFxyXG4gIG5vZGU6IERlY2xhcmF0aW9uU3RhdGVtZW50LFxyXG4gIG5hbWU6IHN0cmluZ1xyXG4pOiBEZWNvcmF0b3JOb2RlIHtcclxuICByZXR1cm4gbm9kZS5kZWNvcmF0b3JzPy5maW5kKGlzRGVjb3JhdG9yKG5hbWUpKSE7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBpc0xpYnJhcnkobm9kZTogU291cmNlKTogYm9vbGVhbiB7XHJcbiAgcmV0dXJuIG5vZGUuaXNMaWJyYXJ5IHx8IG5vZGUuaW50ZXJuYWxQYXRoLnN0YXJ0c1dpdGgoXCJ+bGliL3J0L1wiKTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIG5vdDxUPihmbjogKHQ6IFQpID0+IGJvb2xlYW4pOiAodDogVCkgPT4gYm9vbGVhbiB7XHJcbiAgcmV0dXJuICh0OiBUKSA9PiAhZm4odCk7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiB0b1N0cmluZyhub2RlOiBOb2RlKTogc3RyaW5nIHtcclxuICByZXR1cm4gQVNUQnVpbGRlci5idWlsZChub2RlKTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGNsb25lTm9kZTxUIGV4dGVuZHMgTm9kZT4obm9kZTogVCk6IFQge1xyXG4gIHJldHVybiBjbG9uZURlZXAobm9kZSk7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBpc1VzZXJFbnRyeShzb3VyY2U6IFNvdXJjZSk6IGJvb2xlYW4ge1xyXG4gIHJldHVybiBzb3VyY2Uuc291cmNlS2luZCA9PSBTb3VyY2VLaW5kLlVTRVJfRU5UUlk7XHJcbn1cclxuIl19